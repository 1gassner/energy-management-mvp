import rateLimit from 'express-rate-limit';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport winston from 'winston';\n\n// ==========================================\n// PRODUCTION RATE LIMITING\n// ==========================================\n\n// Strict rate limiting for authentication endpoints\nexport const authRateLimit = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 attempts per window\n  message: {\n    error: 'Too many authentication attempts',\n    message: 'Please wait 15 minutes before trying again',\n    retryAfter: '15 minutes'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  skipSuccessfulRequests: true,\n  handler: (req, res) => {\n    winston.warn('Rate limit exceeded for auth', {\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      path: req.path\n    });\n    \n    res.status(429).json({\n      error: 'Too many authentication attempts',\n      message: 'Please wait 15 minutes before trying again',\n      retryAfter: '15 minutes'\n    });\n  }\n});\n\n// API rate limiting with different tiers\nexport const createApiRateLimit = (tier = 'standard') => {\n  const limits = {\n    free: { windowMs: 15 * 60 * 1000, max: 100 },\n    standard: { windowMs: 15 * 60 * 1000, max: 1000 },\n    pro: { windowMs: 15 * 60 * 1000, max: 5000 },\n    enterprise: { windowMs: 15 * 60 * 1000, max: 10000 }\n  };\n\n  const config = limits[tier] || limits.standard;\n\n  return rateLimit({\n    ...config,\n    message: {\n      error: 'API rate limit exceeded',\n      message: `Too many requests for ${tier} tier. Upgrade for higher limits.`,\n      retryAfter: '15 minutes',\n      tier,\n      limit: config.max\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    skip: (req) => {\n      // Skip rate limiting for health checks and system endpoints\n      return req.path === '/health' || \n             req.path === '/api/v1/info' ||\n             req.path.startsWith('/api/v1/system/');\n    },\n    keyGenerator: (req) => {\n      // Use user ID if authenticated, otherwise IP\n      return req.user?.userId || req.ip;\n    },\n    handler: (req, res) => {\n      winston.warn('Rate limit exceeded for API', {\n        ip: req.ip,\n        userId: req.user?.userId,\n        tier,\n        path: req.path,\n        userAgent: req.get('User-Agent')\n      });\n      \n      res.status(429).json({\n        error: 'API rate limit exceeded',\n        message: `Too many requests for ${tier} tier. Upgrade for higher limits.`,\n        retryAfter: '15 minutes',\n        tier,\n        limit: config.max,\n        upgradeUrl: process.env.UPGRADE_URL || 'https://flowmind.app/pricing'\n      });\n    }\n  });\n};\n\n// Dynamic rate limiting based on user tier\nexport const dynamicRateLimit = (req, res, next) => {\n  const userTier = req.user?.organization?.plan || 'free';\n  const rateLimiter = createApiRateLimit(userTier);\n  rateLimiter(req, res, next);\n};\n\n// ==========================================\n// ENHANCED SECURITY HEADERS\n// ==========================================\n\nexport const productionSecurity = helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"'unsafe-eval'\", \"https://cdn.jsdelivr.net\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://fonts.googleapis.com\"],\n      fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\", \"https:\", \"wss:\", \"ws:\"],\n      mediaSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      childSrc: [\"'self'\"],\n      workerSrc: [\"'self'\"],\n      manifestSrc: [\"'self'\"]\n    },\n  },\n  crossOriginEmbedderPolicy: false, // Disable for WebSocket compatibility\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true\n  }\n});\n\n// ==========================================\n// COMPRESSION WITH OPTIMIZATION\n// ==========================================\n\nexport const productionCompression = compression({\n  level: 6, // Good balance between compression and CPU usage\n  threshold: 1024, // Only compress responses > 1KB\n  filter: (req, res) => {\n    // Don't compress if response is already compressed\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    \n    // Compress all responses by default\n    return compression.filter(req, res);\n  }\n});\n\n// ==========================================\n// REQUEST/RESPONSE MONITORING\n// ==========================================\n\nexport const performanceMonitoring = (req, res, next) => {\n  const startTime = Date.now();\n  const startMemory = process.memoryUsage();\n  \n  // Override res.end to capture response time\n  const originalEnd = res.end;\n  res.end = function(...args) {\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    const endMemory = process.memoryUsage();\n    \n    // Log slow requests\n    if (duration > 5000) { // > 5 seconds\n      winston.warn('Slow request detected', {\n        method: req.method,\n        path: req.path,\n        duration,\n        statusCode: res.statusCode,\n        ip: req.ip,\n        userId: req.user?.userId,\n        memoryUsage: {\n          heapUsedStart: startMemory.heapUsed,\n          heapUsedEnd: endMemory.heapUsed,\n          heapUsedDiff: endMemory.heapUsed - startMemory.heapUsed\n        }\n      });\n    }\n    \n    // Add performance headers\n    res.setHeader('X-Response-Time', `${duration}ms`);\n    res.setHeader('X-Memory-Usage', `${Math.round(endMemory.heapUsed / 1024 / 1024)}MB`);\n    \n    originalEnd.apply(this, args);\n  };\n  \n  next();\n};\n\n// ==========================================\n// ERROR TRACKING AND MONITORING\n// ==========================================\n\nexport const errorTracking = (error, req, res, next) => {\n  const errorId = generateErrorId();\n  \n  // Enhanced error logging\n  winston.error('Request error', {\n    errorId,\n    error: {\n      message: error.message,\n      stack: error.stack,\n      name: error.name\n    },\n    request: {\n      method: req.method,\n      path: req.path,\n      query: req.query,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      userId: req.user?.userId,\n      organizationId: req.user?.organizationId\n    },\n    timestamp: new Date().toISOString()\n  });\n  \n  // Different error responses based on environment\n  if (process.env.NODE_ENV === 'production') {\n    res.status(error.status || 500).json({\n      error: 'Internal server error',\n      message: 'An unexpected error occurred',\n      errorId,\n      timestamp: new Date().toISOString()\n    });\n  } else {\n    res.status(error.status || 500).json({\n      error: error.message,\n      stack: error.stack,\n      errorId,\n      timestamp: new Date().toISOString()\n    });\n  }\n};\n\n// ==========================================\n// HEALTH MONITORING\n// ==========================================\n\nexport const healthMonitoring = {\n  // Check database connection\n  async checkDatabase() {\n    try {\n      const { error } = await supabase\n        .from('organizations')\n        .select('id')\n        .limit(1);\n      \n      return { status: error ? 'unhealthy' : 'healthy', error: error?.message };\n    } catch (err) {\n      return { status: 'unhealthy', error: err.message };\n    }\n  },\n  \n  // Check memory usage\n  checkMemory() {\n    const usage = process.memoryUsage();\n    const totalMB = Math.round(usage.heapTotal / 1024 / 1024);\n    const usedMB = Math.round(usage.heapUsed / 1024 / 1024);\n    const percentage = Math.round((usage.heapUsed / usage.heapTotal) * 100);\n    \n    return {\n      status: percentage > 90 ? 'warning' : 'healthy',\n      totalMB,\n      usedMB,\n      percentage\n    };\n  },\n  \n  // Check response times\n  async checkResponseTime() {\n    const start = Date.now();\n    \n    try {\n      await new Promise(resolve => setTimeout(resolve, 1)); // Minimal async operation\n      const duration = Date.now() - start;\n      \n      return {\n        status: duration > 1000 ? 'warning' : 'healthy',\n        responseTime: duration\n      };\n    } catch (err) {\n      return {\n        status: 'unhealthy',\n        error: err.message\n      };\n    }\n  },\n  \n  // Comprehensive health check\n  async getHealthStatus() {\n    const [database, memory, responseTime] = await Promise.all([\n      this.checkDatabase(),\n      this.checkMemory(),\n      this.checkResponseTime()\n    ]);\n    \n    const overallStatus = [\n      database.status,\n      memory.status,\n      responseTime.status\n    ].includes('unhealthy') ? 'unhealthy' : \n      [\n        database.status,\n        memory.status,\n        responseTime.status\n      ].includes('warning') ? 'warning' : 'healthy';\n    \n    return {\n      status: overallStatus,\n      timestamp: new Date().toISOString(),\n      checks: {\n        database,\n        memory,\n        responseTime\n      },\n      uptime: process.uptime(),\n      version: process.env.npm_package_version || '1.0.0',\n      environment: process.env.NODE_ENV || 'development'\n    };\n  }\n};\n\n// ==========================================\n// GRACEFUL SHUTDOWN HANDLING\n// ==========================================\n\nexport const gracefulShutdown = (server) => {\n  const shutdown = (signal) => {\n    winston.info(`Received ${signal}, starting graceful shutdown...`);\n    \n    server.close((err) => {\n      if (err) {\n        winston.error('Error during server close:', err);\n        process.exit(1);\n      }\n      \n      winston.info('Server closed successfully');\n      \n      // Close database connections\n      // Note: Supabase client handles connections automatically\n      \n      winston.info('Graceful shutdown completed');\n      process.exit(0);\n    });\n    \n    // Force shutdown after 30 seconds\n    setTimeout(() => {\n      winston.error('Forced shutdown after timeout');\n      process.exit(1);\n    }, 30000);\n  };\n  \n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGINT', () => shutdown('SIGINT'));\n  \n  // Handle uncaught exceptions\n  process.on('uncaughtException', (error) => {\n    winston.error('Uncaught Exception:', {\n      error: error.message,\n      stack: error.stack\n    });\n    \n    // Attempt graceful shutdown\n    shutdown('UNCAUGHT_EXCEPTION');\n  });\n  \n  process.on('unhandledRejection', (reason, promise) => {\n    winston.error('Unhandled Rejection:', {\n      reason,\n      promise\n    });\n    \n    // Attempt graceful shutdown\n    shutdown('UNHANDLED_REJECTION');\n  });\n};\n\n// ==========================================\n// PERFORMANCE OPTIMIZATION\n// ==========================================\n\nexport const performanceOptimization = {\n  // Cache frequently accessed data\n  cache: new Map(),\n  \n  // Set cache with TTL\n  setCache(key, value, ttlMs = 300000) { // 5 minutes default\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + ttlMs\n    });\n  },\n  \n  // Get from cache\n  getCache(key) {\n    const item = this.cache.get(key);\n    \n    if (!item) return null;\n    \n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return item.value;\n  },\n  \n  // Clear expired cache entries\n  clearExpiredCache() {\n    const now = Date.now();\n    \n    for (const [key, item] of this.cache.entries()) {\n      if (now > item.expires) {\n        this.cache.delete(key);\n      }\n    }\n  },\n  \n  // Cache middleware\n  cacheMiddleware(ttlMs = 300000) {\n    return (req, res, next) => {\n      const cacheKey = `${req.method}:${req.path}:${JSON.stringify(req.query)}`;\n      const cached = this.getCache(cacheKey);\n      \n      if (cached) {\n        res.setHeader('X-Cache', 'HIT');\n        return res.json(cached);\n      }\n      \n      // Override res.json to cache the response\n      const originalJson = res.json;\n      res.json = function(body) {\n        if (res.statusCode === 200) {\n          performanceOptimization.setCache(cacheKey, body, ttlMs);\n        }\n        res.setHeader('X-Cache', 'MISS');\n        return originalJson.call(this, body);\n      };\n      \n      next();\n    };\n  }\n};\n\n// Clean up cache every 10 minutes\nsetInterval(() => {\n  performanceOptimization.clearExpiredCache();\n}, 10 * 60 * 1000);\n\n// ==========================================\n// UTILITY FUNCTIONS\n// ==========================================\n\nfunction generateErrorId() {\n  return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n// Export all production middleware as a single setup function\nexport const setupProductionMiddleware = (app, server) => {\n  // Security\n  app.use(productionSecurity);\n  \n  // Compression\n  app.use(productionCompression);\n  \n  // Performance monitoring\n  app.use(performanceMonitoring);\n  \n  // Error tracking\n  app.use(errorTracking);\n  \n  // Graceful shutdown\n  gracefulShutdown(server);\n  \n  winston.info('Production middleware setup complete');\n};\n\nexport default {\n  authRateLimit,\n  createApiRateLimit,\n  dynamicRateLimit,\n  productionSecurity,\n  productionCompression,\n  performanceMonitoring,\n  errorTracking,\n  healthMonitoring,\n  gracefulShutdown,\n  performanceOptimization,\n  setupProductionMiddleware\n};